package Minesweeper.sandbox;

/*Generated by MPS */

import javax.swing.JPanel;
import java.awt.Image;
import javax.swing.JLabel;
import java.awt.Dimension;
import javax.swing.ImageIcon;
import java.util.Random;
import java.awt.Graphics;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class EasyMinesweeperBoard extends JPanel {
  private final int NUM_IMAGES = 13;
  public final int CELL_SIZE = 15;

  private final int COVER_FOR_CELL = 10;
  private final int MARK_FOR_CELL = 10;
  private final int EMPTY_CELL = 0;
  private final int MINE_CELL = 9;
  private final int COVERED_MINE_CELL = MINE_CELL + COVER_FOR_CELL;
  private final int MARKED_MINE_CELL = COVERED_MINE_CELL + MARK_FOR_CELL;

  private final int DRAW_MINE = 9;
  private final int DRAW_COVER = 10;
  private final int DRAW_MARK = 11;
  private final int DRAW_WRONG_MARK = 12;

  private final int N_MINES = 8;
  private final int N_ROWS = 10;
  private final int N_COLS = 10;

  private final int BOARD_WIDTH = N_COLS * CELL_SIZE + 1;
  private final int BOARD_HEIGHT = N_ROWS * CELL_SIZE + 1;

  private int[] field;
  private boolean inGame;
  private int minesLeft;
  private Image[] img;

  private int allCells;
  private final JLabel statusbar;

  public EasyMinesweeperBoard(JLabel statusbar) {
    this.statusbar = statusbar;
    initBoard();
  }

  private void initBoard() {
    System.out.println("Board initializing");
    setPreferredSize(new Dimension(BOARD_WIDTH, BOARD_HEIGHT));

    img = new Image[NUM_IMAGES];

    System.out.println("Getting images");
    String picturesFolder = "C:/Users/Vilius/MPSProjects/EducationalGame/languages/Minesweeper/sandbox/resources/";
    System.out.println("CWD: " + System.getProperty("user.dir"));
    for (int i = 0; i < NUM_IMAGES; i++) {
      String path = picturesFolder + i + ".png";
      System.out.println("Path to image: " + path);
      img[i] = (new ImageIcon(path)).getImage();
    }

    addMouseListener(new MinesAdapter());
    newGame();
  }

  private void newGame() {
    int cell;

    Random random = new Random();
    inGame = true;
    minesLeft = N_MINES;

    allCells = N_ROWS * N_COLS;
    field = new int[allCells];
    System.out.println("Setting cells");

    // Step 1 - marking all cells as covered. 
    for (int i = 0; i < allCells; i++) {
      field[i] = COVER_FOR_CELL;
    }

    statusbar.setText(Integer.toString(minesLeft));
    // Step 2 - randomly distribute mines. 
    int i = 0;
    while (i < N_MINES) {
      int position = (int) (allCells * random.nextDouble());

      if ((position < allCells) && (field[position] != COVERED_MINE_CELL)) {
        int current_col = position % N_COLS;
        field[position] = COVERED_MINE_CELL;
        i++;

        // Adding +1 to cells to left from the bomb 
        if (current_col > 0) {
          // Up left 
          cell = position - 1 - N_COLS;
          if (cell >= 0) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
          // Left 
          cell = position - 1;
          if (cell >= 0) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
          // Down left 
          cell = position - 1 + N_COLS;
          if (cell < allCells) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
        }
        // Up from bomb: 
        cell = position + N_COLS;
        if (cell < allCells) {
          if (field[cell] != COVERED_MINE_CELL) {
            field[cell] += 1;
          }
        }
        // Down from bomb: 
        cell = position - N_COLS;
        if (cell >= 0) {
          if (field[cell] != COVERED_MINE_CELL) {
            field[cell] += 1;
          }
        }
        // Adding +1 to cells to right from the bomb 
        if (current_col < (N_COLS - 1)) {
          // Up right 
          cell = position + 1 - N_COLS;
          if (cell >= 0) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
          // Right 
          cell = position + 1;
          if (cell < allCells) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
          // Down right 
          cell = position + 1 + N_COLS;
          if (cell < allCells) {
            if (field[cell] != COVERED_MINE_CELL) {
              field[cell] += 1;
            }
          }
        }
      }
    }
  }

  private void find_empty_cells(int j) {
    int current_col = j % N_COLS;
    int cell;

    // Going left recursively 
    if (current_col > 0) {
      // Upwards 
      cell = j - N_COLS - 1;
      if (cell >= 0) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
      cell = j - 1;
      if (cell >= 0) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
      // Downwards 
      cell = j + N_COLS - 1;
      if (cell < allCells) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
    }
    // Upwards 
    cell = j - N_COLS;
    if (cell >= 0) {
      if (field[cell] > MINE_CELL) {
        field[cell] -= COVER_FOR_CELL;
        if (field[cell] == EMPTY_CELL) {
          find_empty_cells(cell);
        }
      }
    }
    // Downwards 
    cell = j + N_COLS;
    if (cell < allCells) {
      if (field[cell] > MINE_CELL) {
        field[cell] -= COVER_FOR_CELL;
        if (field[cell] == EMPTY_CELL) {
          find_empty_cells(cell);
        }
      }
    }

    // Going right 
    if (current_col < (N_COLS - 1)) {
      // Upwards 
      cell = j - N_COLS + 1;
      if (cell >= 0) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
      cell = j + 1;
      if (cell < allCells) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
      // Downwards 
      cell = j + N_COLS + 1;
      if (cell < allCells) {
        if (field[cell] > MINE_CELL) {
          field[cell] -= COVER_FOR_CELL;
          if (field[cell] == EMPTY_CELL) {
            find_empty_cells(cell);
          }
        }
      }
    }

  }

  public void paintComponent(Graphics g) {
    int uncover = 0;

    for (int i = 0; i < N_ROWS; i++) {
      for (int j = 0; j < N_COLS; j++) {
        int cell = field[(i * N_COLS) + j];

        // If we're drawing a mine and you were playing, it's game over. 
        if (inGame && cell == MINE_CELL) {
          inGame = false;
        }

        // Reveal covered cells if the game is over. 
        if (!(inGame)) {
          if (cell == COVERED_MINE_CELL) {
            cell = DRAW_MINE;
          } else if (cell == MARKED_MINE_CELL) {
            cell = DRAW_MARK;
          } else if (cell > COVERED_MINE_CELL) {
            cell = DRAW_WRONG_MARK;
          } else if (cell > MINE_CELL) {
            cell = DRAW_COVER;
          }
        } else {
          // Draw regular marks and covered cells otherwise. 
          if (cell > COVERED_MINE_CELL) {
            cell = DRAW_MARK;
          } else if (cell > MINE_CELL) {
            cell = DRAW_COVER;
            uncover++;
          }
        }

        // Draw the cell where it's supposed to be: 
        g.drawImage(img[cell], (j * CELL_SIZE), (i * CELL_SIZE), this);
      }
    }
  }

  private class MinesAdapter extends MouseAdapter {
    @Override
    public void mousePressed(MouseEvent e) {
      int x = e.getX();
      int y = e.getY();
      System.out.println("Clicked at X: " + x + ", Y: " + y);
      int cCol = x / CELL_SIZE;
      int cRow = y / CELL_SIZE;
      System.out.println("Row:  " + cRow + ", Column: " + cCol);

      boolean doRepaint = false;

      // Starts a new game if the game recently ended 
      if (!(inGame)) {
        newGame();
        repaint();
      }

      if ((x < N_COLS * CELL_SIZE) && (y < N_ROWS * CELL_SIZE)) {
        // Right click: 
        if (e.getButton() == MouseEvent.BUTTON3) {
          System.out.println("Right click");

          if (field[(cRow * N_COLS) + cCol] > MINE_CELL) {
            doRepaint = true;
            // Put a flag on the cell 
            if (field[cRow * N_COLS + cCol] <= COVERED_MINE_CELL) {
              if (minesLeft > 0) {
                field[cRow * N_COLS + cCol] += MARK_FOR_CELL;
                minesLeft--;
                String msg = Integer.toString(minesLeft);
                statusbar.setText(msg);
              }
            } else {
              // Cell is flagged, so it needs removing 
              field[cRow * N_COLS + cCol] -= MARK_FOR_CELL;
              minesLeft++;
              String msg = Integer.toString(minesLeft);
              statusbar.setText(msg);
            }

          }


        } else {
          // Left click or middle click try to uncover cell. 
          System.out.println("Left/Middle click");
          if (field[(cRow * N_COLS) + cCol] > COVERED_MINE_CELL) {
            return;
          }
          if ((field[(cRow * N_COLS) + cCol] > MINE_CELL) && (field[(cRow * N_COLS) + cCol] < MARKED_MINE_CELL)) {
            field[(cRow * N_COLS) + cCol] -= COVER_FOR_CELL;
            doRepaint = true;

            // Game over 
            if (field[(cRow * N_COLS) + cCol] == MINE_CELL) {
              inGame = false;
            }

            if (field[(cRow * N_COLS) + cCol] == EMPTY_CELL) {
              find_empty_cells((cRow * N_COLS) + cCol);
            }
          }
        }
        // Click was done, need to update the table. 
        if (doRepaint) {
          System.out.println("Repainting");

          repaint();
        }

      }
    }

  }












}
